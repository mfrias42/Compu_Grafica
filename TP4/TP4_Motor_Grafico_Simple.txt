 
Trabajo Pr√°ctico 4 ‚Äì Motor Gr√°fico B√°sico 
Objetivo 
En este trabajo pr√°ctico deber√°n desarrollar un motor gr√°fico b√°sico que permita crear, mover y renderizar figuras geom√©tricas 3D b√°sicas. 
La idea es: 
Crear una ventana con Pyglet. 
Gestionar OpenGL por medio de ModernGL. 
Repasar conceptos de OpenGL (VBO, IBO, VAO, shaders, uniforms). 
Programar una escena 3D con c√°mara perspective (lookAt + perspective). 
Entender y construir el pipeline: ventana ‚Üí contexto ‚Üí escena ‚Üí gr√°ficos ‚Üí shaders. 
Implementar un motor gr√°fico base: estructura modular (Window, Scene, Graphics, ShaderProgram, Camera, objetos). 
Al finalizar, tendr√°n una ventana con objetos 3D que dibujar√° los datos cargados en una escena. 
 
Consigna 
Deben abrir una nueva carpeta con su IDE de preferencia y crear el entorno virtual con el comando ya utilizado: python -m venv .venv 
Activar el entorno virtual con el comando en Windows:  .venv/Scripts/activate  en macOS/Linux source .venv/bin/activate 
Instalar las librer√≠as necesarias con el comando:  pip install pyglet moderngl numpy 
PyGLM 
Seguir las instrucciones paso a paso para tener el c√≥digo completo. 
 
Gu√≠a paso a paso: 
CREAR LOS ARCHIVOS. 
En la carpeta de tu proyecto, crear los siguientes archivos y directorios: 
Notar: podemos crear los shader con las extensiones .vert y .frag a modo de hacer m√°s legible nuestra estructura de proyecto. 
 
basic_engine/ 
‚îú‚îÄ .venv/ 
‚îú‚îÄ shaders/ 
‚îÇ  ‚îú‚îÄ basic.vert ‚îÇ  ‚îî‚îÄ basic.frag 
‚îú‚îÄ src/ 
‚îÇ  ‚îú‚îÄ main.py 
‚îÇ  ‚îú‚îÄ window.py 
‚îÇ  ‚îú‚îÄ scene.py 
‚îÇ  ‚îú‚îÄ shader_program.py 
‚îÇ  ‚îú‚îÄ graphics.py 
‚îÇ  ‚îú‚îÄ camera.py ‚îÇ  ‚îî‚îÄ cube.py 
La l√≥gica principal del motor se organiza de la siguiente manera:  
La ventana es el punto de entrada: inicializa el contexto gr√°fico y carga una escena. La escena contiene una colecci√≥n de objetos 3D y una c√°mara que define el punto de vista. 
En cada frame, la escena se encarga de renderizar todos los objetos de acuerdo con la posici√≥n y orientaci√≥n de la c√°mara. 
La representaci√≥n gr√°fica de cada objeto se apoya en dos componentes clave: 
Graphics: administra los datos del objeto (geometr√≠a, v√©rtices, colores, buffers). ShaderProgram: define c√≥mo se procesan esos datos en la GPU (transformaciones, rotaciones, colores, efectos, etc.). 
En conjunto, este flujo asegura que cada cuadro de la animaci√≥n se construya correctamente: la ventana gestiona el contexto, la escena organiza los elementos y la c√°mara, y finalmente los objetos se dibujan en pantalla gracias a la interacci√≥n entre Graphics y ShaderProgram. 
 
DESARROLLO DE SHADERS M√çNIMOS: BASIC.VERT Y BASIC.FRAG Crear los shaders m√≠nimos para que el programa funcione: 
Vertex Shader: inyecci√≥n de c√≥digo en el Render Pipeline de la GPU que gestiona v√©rtice por v√©rtice la geometr√≠a de un objeto poligonal. Siempre debe configurar el valor gl_Position para que la secuencia no de error. 
 
Fragment Shader: inyecci√≥n de c√≥digo en el Render Pipeline de la GPU que gestiona cada p√≠xel generado en la rasterizaci√≥n de un objeto poligonal. Siempre debe devolver un vec4 de color (r,g,b,a) donde alpha es la transparencia del color. 
 
  
 
MAIN.PY  
main.py: ejecuta el programa. Crea una ventana Window, un ShaderProgram, una Scene, crea las instancias de los objetos gr√°ficos (en este caso Cube), crea la c√°mara y la posiciona. Por √∫ltimo, agrega los objetos en la escena y corre el loop principal del programa. 
 
 
 
WINDOW.PY 
window.py: extiende de la clase Window de Pyglet. Se encarga de gestionar la creaci√≥n de la ventana y sus eventos. Crea el contexto de ModernGL para trabajar con OpenGL. 
Implementa el m√©todo on_draw que limpia y renderiza la escena en cada frame. Tambi√©n implementa on_resize para escalar el contexto al escalar la ventana (y que no se vea lento) y run para ejecutar el loop principal de Pyglet. 

SHADER_PROGRAM.PY 
 
shader_program.py: se encarga de cargar los shaders vertex y fragment (en este caso) en el Program de ModernGL. Permite tambi√©n actualizar los valores de los uniforms de los shaders. 
 
GRAPHICS.PY 
graphics.py: crea el VBO, el IBO y VAO con el ShaderProgram y el format de atributos (en este caso ‚Äú3f 3f‚Äù, ‚Äúin_pos‚Äù, ‚Äúin_color‚Äù). Implementa el m√©todo render() para renderizar el VAO en el context, seg√∫n los valores y funciones indicados en el ShaderProgram. 
 

CAMERA.PY 
camera.py: definici√≥n simple de una c√°mara con su matrix de perspectiva y de view (lookAt). √ötil para obtener las coordenadas de la c√°mara y su proyecci√≥n (qu√© es lo que est√° viendo). 
 
 
 
CUBE.PY 
cube.py: definici√≥n b√°sica de un cubo. Contiene el array con sus v√©rtices + color e √≠ndices para luego crear el VBO y el IBO. Adem√°s tiene una matrix del modelo que nos permite aplicar transformaciones al cubo (moverlo, rotarlo, escalarlo). 
  
En self.vertices y self.indices reemplazar por (c√≥digo para copiar y pegar): 
SCENE.PY 
scene.py: posiciona una c√°mara, administra los objetos y sus Graphics (VBO, VAO, ShaderProgram). Realiza transformaciones a los objetos que est√°n en la escena y actualiza sus shaders. Tambi√©n actualiza viewport en on_resize. 

Ejecuta el programa desde main.py y observa el resultado en pantalla. 
¬øQu√© notas sobre los cubos? 
 
¬øSe dibujan correctamente o parecen estar ‚Äúinvisibles‚Äù? 
 
Piensa: el vertex shader que les dimos no trabaja directamente con las coordenadas locales de cada objeto. Antes de que la GPU pueda mostrarlos, es necesario que esas coordenadas sean transformadas teniendo en cuenta tres aspectos fundamentales: 
La geometr√≠a propia del objeto (su sistema de coordenadas locales). 
 
La posici√≥n y orientaci√≥n de la c√°mara (qu√© mira y desde d√≥nde). 
 
La proyecci√≥n de la escena (c√≥mo se proyecta el espacio 3D en la pantalla 2D). 
 
Para unir todo esto, normalmente se construye una √∫nica matriz que combina las tres transformaciones: la MVP (Model‚ÄìView‚ÄìProjection). Esa matriz debe ser calculada para cada objeto de la escena y enviada al shader en cada frame. 
Esto convierte la posici√≥n de la c√°mara en el ‚Äúpunto de origen‚Äù y la posici√≥n del objeto en t√©rminos de ese nuevo sistema de coordenadas (trasladando el objeto). 
Actualmente, en la escena se ejecuta directamente al vao.render(). Eso significa que la geometr√≠a llega al shader sin ninguna transformaci√≥n adicional. El shader, sin embargo, est√° esperando una matriz Mvp que nunca se actualiza (por lo tanto es una matriz de ceros). 
Para resolverlo: 
Cada objeto tiene un m√©todo como get_model_matrix() que describe su posici√≥n, rotaci√≥n y escala en la escena. 
 
La c√°mara ya expone su view matrix y su projection matrix. 
 
Con esas tres piezas se puede armar la matriz final: 
Mvp = Projection √ó View √ó Model 
 
Esa matriz debe enviarse al shader a trav√©s del uniform Mvp antes de renderizar cada objeto. 
Preguntas para guiar la reflexi√≥n 
¬øQu√© ocurre si no se aplica la matriz de vista de la c√°mara? 
¬øY si omitimos la proyecci√≥n? 
¬øPor qu√© necesitamos recalcular Mvp para cada objeto y no basta con hacerlo una sola vez?	 
Ejecuta el programa nuevamente desde main.py y observa atentamente la escena. 
¬øC√≥mo se ven ahora los cubos? 
 
¬øTe parece que la superposici√≥n entre ellos es la correcta? 
 
Piensa: cuando dibujamos varios objetos en un espacio 3D, hay que decidir qu√© superficie queda delante y cu√°l detr√°s. La GPU no lo ‚Äúadivina‚Äù autom√°ticamente: depende de un mecanismo que compara profundidades en cada fragmento que se dibuja. 
Actualmente, ese mecanismo no est√° activado. El resultado es que algunos pol√≠gonos aparecen por encima de otros aunque, seg√∫n la geometr√≠a, deber√≠an estar ocultos. 
Para resolverlo: 
En OpenGL existe un buffer de profundidad que guarda, para cada pixel, qu√© tan lejos est√° la superficie ya dibujada. 
 
Antes de pintar un nuevo fragmento, la GPU compara su valor de profundidad contra el que ya est√° almacenado. 
 
Si este chequeo no se realiza, simplemente se pinta todo en el orden de dibujo, sin importar cu√°l est√© realmente adelante. 
 
En ModernGL (y en OpenGL en general), este chequeo debe activarse expl√≠citamente. La 
instrucci√≥n es la siguiente y se debe hacer por cada frame en el que se actualiza la ventana: ctx.enable(moderngl.DEPTH_TEST) 
 
 
Entrega 
C√≥digo Python completo y funcionando. 
Al menos una imagen generada por su programa (un PNG con una escena creada por ustedes) 
Enviar por email a 2436805@ucc.edu.ar 
 
Bonus (opcional üòè) 
‚óè Agregar m√°s figuras 3D (por ejemplo, una esfera, un cono). ¬øTe anim√°s a crear una sphere.py? Podes usar IA para calcular los v√©rtices e √≠ndices. 
 
 
